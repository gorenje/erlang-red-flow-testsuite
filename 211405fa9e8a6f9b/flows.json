[{"id":"211405fa9e8a6f9b","type":"tab","label":"[.docu] supervisor node architecture","disabled":false,"info":"<small><i>[Share link](https://flows.red-erik.org/f/211405fa9e8a6f9b)</i></small>\n\n## Supervisor node Erlang architecture\n\nThis is a step on from [function node architecture](https://flows.red-erik.org/f/1fd621a674360b5d) and describes the workings of the supervisor node. \n\nThis is a single supervisor supervising a single node, I won't go into the the details of [supervisor trees](https://flows.red-erik.org/f/83c5e1824f32abec) or [supervisors of supervisors of supervisor of ....](https://flows.red-erik.org/f/e447b0048a5983b5).\n\n## Flowchart\n\n```mermaid\n%% change this to LR Node-RED like UML\ngraph TB\n35330836e77bc5c7@{ shape: \"fr-rect\", label: \"Supervisor Node \\n &lt;ered_nodes.erl&gt;\" } -- \"create_pids_for_nodes#47;2\" --> 5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" }\n5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" } -- \"exit#40;normal#41;\" --> d48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" }\n5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" } -- \"ered_node_erlsupervisor:create_children#47;3\" --> 6e828720bfd223d5@{ shape: \"rect\", label: \"supervisor \\n &lt;supervisor&gt;\" }\n4d3474827cacd5c3@{ shape: \"st-rect\", label: \"system \\n &lt;ered_nodes.erl&gt;\" } -. \"handle_event#40;#123;registered#125;#41;#47;2\" .-> 5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" }\n6e828720bfd223d5@{ shape: \"rect\", label: \"supervisor \\n &lt;supervisor&gt;\" } -- \"ered_supervisor_manager:start_link#47;3\" --> d48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" }\nd48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" } -. \"! #123;'DOWN' ... shutdown#125;\" .-> 5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" }\nd48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" } -. \"! 'EXIT', normal\" .-> 6f2cc3cda256f2c8@{ shape: \"rect\", label: \"function 2 \\n &lt;ered_node&gt;\" }\nd48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" } -- \"ered_startup:spin_up_and_link_node#47;2\" --> 6f2cc3cda256f2c8@{ shape: \"rect\", label: \"function 2 \\n &lt;ered_node&gt;\" }\nsubgraph at flow start up time\n5914bd748c211abf\n4d3474827cacd5c3\nsubgraph start supervisor manager\n6e828720bfd223d5\nd48ecbeb4b63f6e6\nend\nend\n```\n\n## Terminology\n\nIn the flow-chart:\n\n- rectangles are Erlang processes\n- solid arrows are function calls that create processes\n- dotted arrows are Erlang messages being sent between processes\n\nThe \"system\" is simply the running instance of Erlang-Red and the framed rectangle is the JSON description of the supervisor node (in a certain sense).\n\n## Details\n\nThe flowchart presents the start up mechanism of the <a class=\"ahl-node-only\" data-ids=\"94ae573ea1b956d3\">supervisor</a> node. The node is first spun up via the `create_pids_for_nodes/2` function which triggers the [`ered_node:start/2`](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/ered_node.erl#L22-L23) callback.\n\nOnce that has happened the supervisor node process receive a `registered/2` event and spins up its children using the `ered_supervisor_manager` module - which is the supervisor responsible for starting and stopping the children. It uses the  the configuration of the node to spin up child processes for all the nodes the supervisor node is supervising. It spins up the child processes using the `ered_startup:spin_up_and_link_node/2` function.\n\nThe ered_supervisor_manager dies when the intensity-over-period is reached. This death would take out the process representing the supervisor node - supervisors can only be started linked to their calling process. As the [mantra](https://blog.openmindmap.org/blog/erlang-red#nodes-will-never-die) is *node processes shall never die*, it is not desirable that the ered_supervisor_manager should also take down the supervisor node process. Hence there is a supervisor between the node process and the manager process: the \"supervisor &lt;supervisor&gt;\" process is a supervisor behaviour configured to neither restart the manager nor to die itself. It buffers the death of the manager and not much more.\n\nWhen the supervisor manager does die, the supervisor node process is informed via `'DOWN'` message that is sent to the supervisor node process because the process is monitoring the manager process. A monitor is setup when the supervisor manager process sends a `{supervisor_started, SupMgrPid}` message to the supervisor node process.\n\nThis setup works fine if this supervisor node is not being supervised by another supervisor, i.e., supervisor-of-supervisor pattern. The problem there is the death of the ered_supervisor_manager has to be propagated up the supervisor chain. But this node does everything to prevent itself from dying when the supervisor dies. In a supervisor-of-supervisor pattern, this node needs to die since the supervisor is supervising the node process NOT the process of the supervisor that dies when the children die.\n\nLuckily what happens is that this node receives a message when the supervisor goes down - the \"{'DOWN', ...}\" message. It receives this message to alter its status - from started to dead. What we do is set a flag on the NodeDef of this node to tell it to go down if and only if its supervisor goes down. We only set this flag if the supervisor node is being supervised. \n\nWhen the node goes down, the supervisor supervising it, restarts the entire node.\n\n## Discussion\n\n### Nested supervisors\n\nWhat is not shown is the *chicken & egg* issues surrounding the configuration of supervisor nodes. As part of the initialisation phase before starting a flow, nodes that are managed by a supervisor will not be started by Erlang-Red directly rather indirectly via the supervisor. This causes issues when supervisors supervise supervisors, i.e., nesting of supervisors.\n\nBoth issues are addressed in the `ered_startup:create_pids_for_nodes/2` call. It is responsible for first identifying all supervisors, then removing the nodes they supervise from the list of nodes to be started and finally it defines an ordering of how supervisors are started - since these start other supervisors that then start node processes. These tasks are covered in the `ered_node_erlsupervisor:extract_nodes/3`, `ered_nodes:supervisor_filter_nodes/5` and `ered_nodes:extract_supervisors/1` functions.\n\n### Buffer supervisor - `supervisor <supervisor>` process\n\nThe \"buffer supervisor\" is a thorn in the backside however I have not found a better approach to the need of keeping the supervisor node process alive while the supervisor dies when failure rate gets to intensive. Important to remember that a supervisor process cannot to spun up \"off-the-clock\", i.e., without being linked to the parent process. It is this linkage the causes the issue: it pulls the supervisor node process down with it when the supervisor fails.\n\nMuch as the [function node](https://flows.red-erik.org/f/1fd621a674360b5d), which has up to two processes *per* Erlang-Red message, there are valid reasons for having the \"buffer supervisor\". I am aware of the \"let it fail\"-mantra of Erlang, however if everything fails then there is nothing to start it up again. Perhaps having the supervisor node processing being a `supervisor` behaviour instead of a `ered_node` behaviour would help. But no it does not since the supervisor behaviour cannot handle Erlang messages sent to it from other processes. Combining the two behaviours isn't possible because there is an overlap in the `init/1` function.\n\n### Supervising the Supervisor\n\nAs mentioned above, there are behavioural changes when the supervisor knows its being supervised. All nodes that are being managed by a supervisor are informed of this during the start up phase (not shown above) by being sent the `{being_supervised, ...}` message. This message is sent right after the `registered` message shown above.\n\nOnce the supervisor node knows it is being monitor, it will shutdown when its supervisor manager dies. That is, when the intensity/period configuration becomes critical and the manager stops restarting processes.\n\nAnother task the supervisor node process has to perform if it is being supervised is to shutdown any managers *if* it is told to shut down. This happens when the supervising supervisor restarts process via a restart policy of \"one for all\" or \"rest for one\", meaning a healthy process is restarted because an unhealthy one dies.\n\nThis done by the supervisor node process sending the manager a message via the `exit(normal)` function. This then ensures that the supervisor manager shuts down all nodes being managed by the supervisor node.\n\n## Code\n\n- [ered_node_erlsupervisor.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/nodes/ered_node_erlsupervisor.erl)\n- [ered_supervisor_manager.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/managers/ered_supervisor_manager.erl)\n- [ered_nodes.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/ered_nodes.erl)\n- [ered_ndoe.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/ered_node.erl) behaviour\n\n","env":[{"name":"ERED_TIMEOUT","value":"1","type":"num"}]},{"id":"e8765b1cd757b1d3","type":"inject","z":"211405fa9e8a6f9b","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":187,"y":506,"wires":[["6899b24a5114a6b8"]]},{"id":"03d96dfe714b55a0","type":"debug","z":"211405fa9e8a6f9b","name":"debug 1","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"","statusType":"counter","x":745,"y":506,"wires":[]},{"id":"6899b24a5114a6b8","type":"function","z":"211405fa9e8a6f9b","name":"function 2","func":"%% Code here is wrapped in a fun (Msg) call\n%% fun (Msg) ->\n    Msg\n%% end.\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":453,"y":506,"wires":[["03d96dfe714b55a0"]]},{"id":"94ae573ea1b956d3","type":"erlsupervisor","z":"211405fa9e8a6f9b","name":"","scope":["6899b24a5114a6b8"],"supervisor_type":"static","strategy":"one_for_one","auto_shutdown":"never","intensity":"1","period":"5","child_type":"worker","child_restart":"permanent","child_shutdown":"brutal_kill","child_shutdown_timeout":"0","x":447,"y":374.5,"wires":[[]]}]