[{"id":"3bba732ae17b01a9","type":"tab","label":"[function] speaks Erlang","disabled":false,"info":"# Funtion node speaks Erlang \n\nI guess this would be an Erlang-Red only test. It's the function node now styled in Erlang code and only Erlang Code.\n\n## On Start and On Stop tabs\n\nImportant to note are the \"On Start\" and \"On Stop\" tabs in the function node. These can alter the definition of the node by returning a `NodeDef` map. In fact, they have to return the NodeDef map else bad things will happen.\n\nIf this is confusing then best not to use the start and stop tabs in the function definition.\n\nThe code found in the \"On Start\" and \"On Stop\" tabs is wrapped inside the following function definition:\n\n```erlang\nfun(NodeDef, Msg) -> \n   %% code here\nend.\n```\n\nThat function is **required** to return the NodeDef argument (it's just a map) as it was passed in or altered. The Msg maps only contains a reference to the websocket - usefully for updating status information of the node.\n\n## On Message tab\n\nThe code in the \"On Message\" tab is also wrapped in a funtion with the following signature:\n\n```erlang\nfun(NodeDef, Msg) -> \n   %% code here\nend.\n```\n\nThe \"On Message\" code is **required** to return one of:\n\n- `Msg` - a single message object which is sent to its first output port\n- `undefined` - single atom value of undefined indicates that the function node has no message to be passed on\n- `[Msg,undefined,...]` - a list of either maps or undefined atom. The list is used to define outputs for multiple output ports. See this [test](https://flows.red-erik.org/f/c5f513bc380bc30a) for more details.\n\nAny other return value will lead to bad things happening, what these things are remains unclear. See this [test](https://flows.red-erik.org/f/49c0a3ed69d61f56) for more details.\n\n","env":[]},{"id":"6080018c8cb9548a","type":"group","z":"3bba732ae17b01a9","name":"handle functions with no output ports","style":{"label":true},"nodes":["ddf62e1870de423c","08b00673ab69fa2a"],"x":70,"y":340,"w":311,"h":232},{"id":"77d7ebb1b0dbc1f2","type":"group","z":"3bba732ae17b01a9","name":"single output port","style":{"label":true},"nodes":["8635e881fe0a171d","f9fb40d63b894db4","91c695565075cf5b"],"x":470,"y":258,"w":343,"h":436.5},{"id":"8635e881fe0a171d","type":"inject","z":"3bba732ae17b01a9","g":"77d7ebb1b0dbc1f2","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":576,"y":299,"wires":[["f9fb40d63b894db4"]]},{"id":"f9fb40d63b894db4","type":"function","z":"3bba732ae17b01a9","g":"77d7ebb1b0dbc1f2","name":"function 2","func":"%% Code is called in a function wrapper:\n%%     fun (NodeDef, Msg) -> .... end.\n%% and must return a Msg map.\n\nMsg2 = maps:put(payload, \"hello world\", Msg),\nmaps:put(start_value, maps:get('_start_was_called', NodeDef), Msg2)\n\n","outputs":1,"timeout":0,"noerr":0,"initialize":"%% Code added here will be run once\n%% whenever the node is started.\n%% This gets wrapped in a function definition:\n%%   fun (NodeDef,Msg) -> ... end\n%% and must return a NodeDef map.\n\n%% ered_nodered_comm:send_out_debug_msg(NodeDef, Msg, <<\"function started\">>, normal),\n\nmaps:put('_start_was_called', 10, NodeDef)\n","finalize":"%% Code added here will be run once\n%% whenever the node is started.\n%% This gets wrapped in a function definition:\n%%   fun (NodeDef,Msg) -> ... end\n%% and must return a NodeDef map.\n\nered_nodered_comm:send_out_debug_msg(NodeDef, Msg, <<\"function stopped\">>, warning),\n\nNodeDef\n","libs":[],"x":633,"y":486,"wires":[["91c695565075cf5b"]]},{"id":"91c695565075cf5b","type":"ut-assert-values","z":"3bba732ae17b01a9","g":"77d7ebb1b0dbc1f2","name":"","rules":[{"p":"payload","pt":"msg","t":"eql","to":"hello world","tot":"str"},{"p":"start_value","pt":"msg","t":"eql","to":"10","tot":"num"}],"x":707,"y":653.5,"wires":[[]]},{"id":"ddf62e1870de423c","type":"function","z":"3bba732ae17b01a9","g":"6080018c8cb9548a","name":"function 1","func":"%% Code is called in a function wrapper:\n%%     fun (NodeDef, Msg) -> .... end.\n%% and must return a Msg map.\n\nMsg2 = maps:put(payload, \"hello world\", Msg),\nmaps:put(start_value, maps:get('_start_was_called', NodeDef), Msg2)\n\n","outputs":0,"timeout":0,"noerr":0,"initialize":"%% Code added here will be run once\n%% whenever the node is started.\n%% This gets wrapped in a function definition:\n%%   fun (NodeDef,Msg) -> ... end\n%% and must return a NodeDef map.\n\n%% ered_nodered_comm:send_out_debug_msg(NodeDef, Msg, <<\"function started\">>, normal),\n\nmaps:put('_start_was_called', 10, NodeDef)\n","finalize":"%% Code added here will be run once\n%% whenever the node is started.\n%% This gets wrapped in a function definition:\n%%   fun (NodeDef,Msg) -> ... end\n%% and must return a NodeDef map.\n\nered_nodered_comm:send_out_debug_msg(NodeDef, Msg, <<\"function stopped\">>, warning),\n\nNodeDef\n","libs":[],"x":295,"y":531,"wires":[]},{"id":"08b00673ab69fa2a","type":"inject","z":"3bba732ae17b01a9","g":"6080018c8cb9548a","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":176,"y":381,"wires":[["ddf62e1870de423c"]]}]