[{"id":"0697e9392947472e","type":"tab","label":"[status] source map inside the status map","disabled":false,"info":"## Structure of the status attribute\n\nThe status attribute set on the msg object has the following Structure:\n\n```\n status: {\n    fill: \"grey\"\n    shape: \"dot\"\n    text: \"e\"\n    source: {\n      id: \"97abdd5fa249b712\"\n      type: \"debug\"\n      name: \"debug 395\"\n    },\n },\n```\n\nthat is the source is encapsulated inside the status map.","env":[]},{"id":"c6acfc7fedcfd0c3","type":"status","z":"0697e9392947472e","name":"","scope":["670fe518d1a73294","73e08ba258f14433"],"x":409,"y":591,"wires":[["bce292ea73f07bd5"]]},{"id":"bce292ea73f07bd5","type":"debug","z":"0697e9392947472e","name":"debug 7","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":576,"y":693,"wires":[]},{"id":"5909c551445da5ee","type":"function","z":"0697e9392947472e","name":"function 2","func":"%% Code here is wrapped in a fun (Msg) call\n%% fun (Msg) ->\n    #{ <<\"payload\">> := Payload } = Msg,\n    Msg\n%% end.\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":388,"y":460,"wires":[[]]},{"id":"990b30835b3279c1","type":"erlmodule","z":"0697e9392947472e","name":"","module_name":"node_helpers","code":"-module(node_helpers).\n\n-import(ered_nodered_comm, [\n    send_out_debug_msg/4,\n    node_status/5,\n    node_status_clear/2,\n    post_exception_or_debug/3\n]).\n\n-import(ered_messages, [\n    set_prop_value/3\n]).\n\n-import(ered_nodes, [\n    send_msg_to_connected_nodes/2,\n    send_msg_on/2\n]).\n\n%%\n%% Node helpers, things that affect what the state of the node \n-export([\n    status/5,\n    status_with_clear/6,\n    exception/3,\n    debug/4,\n    unsupported/3\n]).\n\n%%\n%% Message helpers to help updating content on the message map\n-export([\n   msg_update/3,\n   msg_send/2,\n   msg_send_on_port/3\n]).\n\n%%\n%% Sends the message out on a specific port.\n%% If a function happens to have multiple ports, then\n%% use this to send a message out on exactly one of those\n%% ports. \n%% Ports are 1-based, i.e. they start at 1 and increase by\n%% one.\n-spec msg_send_on_port(\n        Port :: 0..65322,\n        Msg:: map(),\n        NodeDef :: map()\n) -> any() | none().\nmsg_send_on_port(_, _, #{ <<\"wires\">> := [] } ) ->\n    ignore;\nmsg_send_on_port(1, Msg, #{ <<\"wires\">> := [SetOfWires | _RestWires] }) ->\n    send_msg_on(SetOfWires, Msg);\nmsg_send_on_port(Port, Msg, #{ <<\"wires\">> := [_SetOfWires | RestWires] }) when Port > 1 ->\n    msg_send_on_wires(Msg, RestWires, Port - 1);\nmsg_send_on_port(_, _, _)  ->\n    ignore.\n\nmsg_send_on_wires(_, [], _) ->\n    ignore;\nmsg_send_on_wires(Msg, [SetOfWires | _RestWires], 1) ->\n    send_msg_on(SetOfWires, Msg);\nmsg_send_on_wires(Msg, [_SetOfWires | RestWires], Port) ->\n    msg_send_on_wires(Msg, RestWires, Port - 1).\n\n%%\n%% Send out a message to all nodes connected this this node.\n%% A function node can then either return the message and the \n%% message will be sent again or it returns the atom `undefined` and\n%% nothing happens. Because it has already sent the messages.\n-spec msg_send(\n        Msg :: map(),\n        NodeDef :: map()\n) -> any() | none().\nmsg_send(Msg, NodeDef) ->\n    send_msg_to_connected_nodes(NodeDef, Msg).\n    \n%%\n%% Update a value in the msg, creating nested maps and lists as needed.\n%% Property is defined in `key.dot.sq[number]` form, i.e., whatever Node-RED\n%% supports, this can too.\n-spec msg_update(\n        Msg :: map(),\n        PropName :: string(),\n        Value :: any() \n) -> map().\nmsg_update( Msg, PropName, Value ) ->\n    set_prop_value(PropName, Value, Msg).\n\n%%\n%% Add a node status: \n-spec status( \n       Msg :: map(),\n       NodeDef :: map(),\n       Txt :: binary(),\n       Clr :: 'grey' | 'yellow' | 'blue' | 'red' | 'green',\n       Shp :: 'ring' | 'dot' \n) -> Msg :: map().\nstatus(#{'_ws' := WsName} = Msg, NodeDef, Txt, Clr, Shp) ->\n    node_status(WsName, NodeDef, Txt, atom_to_binary(Clr), atom_to_binary(Shp)),\n    Msg.\n\n%%\n%% show status and then clear it again after Timeout seconds\n-spec status_with_clear( \n       Msg :: map(),\n       NodeDef :: map(),\n       Txt :: binary(),\n       Clr :: 'grey' | 'yellow' | 'blue' | 'red' | 'green',\n       Shp :: 'ring' | 'dot',\n       Timeout :: integer()\n) -> Msg :: map().\nstatus_with_clear(#{'_ws' := WsName} = Msg, NodeDef, Txt, Clr, Shp, Timeout) ->\n    node_status(WsName, NodeDef, Txt, atom_to_binary(Clr), atom_to_binary(Shp)),\n    timer:apply_after(Timeout * 1000, fun() -> node_status_clear(WsName, NodeDef) end),\n    Msg.\n\n%%\n%% Raise an exception that can be caught by a \n%% catch node.\n-spec exception(\n        Msg :: map(),\n        NodeDef :: map(),\n        ErrorMsg :: binary()\n) -> Msg :: map().\nexception(Msg, NodeDef, ErrorMsg) ->\n    post_exception_or_debug(NodeDef, Msg, ErrorMsg),\n    Msg.\n\n%%\n%% Post a debug message to the debug panel\n-spec debug(\n        Msg :: map(),\n        NodeDef :: map(),\n        ErrorMsg :: binary(),\n        ErrorType :: 'error' | 'warning' | 'notice' | 'normal'\n) -> Msg :: map().\ndebug(Msg, NodeDef, ErrorMsg, ErrorType) ->\n    send_out_debug_msg(NodeDef, Msg, ErrorMsg, ErrorType),\n    Msg.\n\n%%\n%% Unsupported message, advices the user that something is not\n%% supported by the implementation. This will generate a mesage\n%% in the debug panel to raise the issue with the user.\n-spec unsupported(\n        Msg :: map(),\n        NodeDef :: map(),\n        ErrorMsg :: binary()\n) -> Msg :: map().\nunsupported(Msg, NodeDef, ErrorMsg) ->\n    ered_nodered_comm:unsupported(NodeDef, Msg, ErrorMsg),\n    Msg.","x":160,"y":233,"wires":[]}]