[{"id":"2d51a745ca17dc05","type":"tab","label":"[.docu] Erlang-Red flow startup","disabled":false,"info":"<script>\n$(function(){\n    $('#flowdatacontainer').hide();\n    $('#flowtitle').html($('#flowtitle').text().replace(\"[.docu]\",\"\")).css('font-size', '1.9em');\n})\n</script>\n\n<small><i>[Share](https://flows.red-erik.org/f/2d51a745ca17dc05)</i></small>\n\nA visualisation of [ered_startup](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl) module which is responsible for spinning up all processes required for the execution of a flow.\n\nFlow nodes are represented by an Erlang processes, each node has a main process that is independent of all other node processes. Nodes are configured with their immediate downstream connections. Processes use this configuration to send messages to other Erlang processes representing those downstream nodes. \n\nDescribed here is how these processes are started from a JSON description of nodes and flows. This description focuses solely on the initialisation of Erlang-Red flows when these are deployed. This description does not concern itself with the Erlang supervised [services](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/erlang_red_sup.erl) started at Erlang-Red start up time. \n\nThis description comprises three parts, the first two described the step-by-step sequence that creates Erlang processes from JSON node descriptions. The third part describes the usage of that sequence to instantiate a flow as Erlang processes and pass a message through that flow.\n\n## Start up - Phase one\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph LR\n647f1caf18f4e461@{ shape: \"braces\", label: \"Outside World\" } -- \"create_pids_for_nodes#47;2\" --> cd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;1#41;** call_to\" --> f7b57f5fa2684033@{ shape: \"text\", label: \"store_config_nodes#47;2\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;2#41;** call_to\" --> 06d71e4d226a0b66@{ shape: \"text\", label: \"install_module_node_code#47;2\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;3#41;** call_to\" --> 6f2a3728abcf40e8@{ shape: \"text\", label: \"extract_supervisors#47;1\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;4#41;** call_to\" --> 4b74abd49857f467@{ shape: \"text\", label: \"supervisor_filter_nodes#47;5\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;5#41;** call_to\" --> 993f43fc0fd83c72@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" }\nf7b57f5fa2684033@{ shape: \"text\", label: \"store_config_nodes#47;2\" } -- \"store_config_node\" --> deebe7665f77dc9a@{ shape: \"lin-cyl\", label: \"ered_config_store \\n &lt;gen_server&gt;\" }\n06d71e4d226a0b66@{ shape: \"text\", label: \"install_module_node_code#47;2\" } -- \"install#47;2\" --> b8a1bc7329daec62@{ shape: \"notch-rect\", label: \"ered_node_erlmodule\" }\n6f2a3728abcf40e8@{ shape: \"text\", label: \"extract_supervisors#47;1\" } == \"Supervisors\" ==> cd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" }\n4b74abd49857f467@{ shape: \"text\", label: \"supervisor_filter_nodes#47;5\" } -- \"extract_nodes#47;2\" --> 94123abe4da26501@{ shape: \"notch-rect\", label: \"Supervisor Module\" }\n993f43fc0fd83c72@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" } == \"Pids\" ==> 647f1caf18f4e461@{ shape: \"braces\", label: \"Outside World\" }\nsubgraph \"ered_startup:create_pids_for_nodes#47;2\"\ncd65242359acde9d\nf7b57f5fa2684033\n06d71e4d226a0b66\n6f2a3728abcf40e8\n4b74abd49857f467\n993f43fc0fd83c72\nend\n```\n*Function calls are ordered and shown in **(1)** numbering. Thick arrows are return values, thin arrows are function calls.*\n\nThe `{ Outside World }` passes a collection of nodes to the `create_pids_for_nodes/2` function. These nodes contain all the nodes that define a Node-RED flow *representation*, which include:\n\n- `tab` node that represents a collection of nodes grouped by a tab within the Node-RED flow editor. The ID of the tab node defines the `z` value for each node that is contained in that tab. A tab node also defines environment parameters for the entire flow, i.e., group of nodes.\n- `config` nodes that define connection details (for example) to third party services. Configuration details are stored in config nodes and shared amongst multiple instances of service nodes. \n- `service` nodes represent connections to third-party services such as MQTT or HTTP connections. These are configured using config nodes.\n- `group` nodes that represent groupings of within a tab within the Node-RED flow editor. The ID of the group node defines the `g` attribute of nodes that belong to the group.\n- `junction` node that represent junction points with flows. Their main purpose is visually connecting many streams of data into a single connection. Any messages received by a junction node are unaltered and transparently passed to all the junctions downstream connections.\n- All other nodes that represent the logic of the flow. The behaviour and interaction of each of these nodes are defined by their own [module](https://github.com/gorenje/erlang-red/tree/82075b02258dfb31a566213c168c890c4564dafd/src/nodes). The [startup module](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl#L292-L331) defines the mapping between node type and module for handling that type. This mapping needs to be updated for each new node type.\n\nDuring the initial creation time of the processes, the start up process loops through the collection of nodes several times. For example, to store the config nodes, all nodes are iterated through. To install module nodes, all nodes are iterated through. This is done because there is no order defined in flow JSON files as passed to the server. A Node-RED flow JSON file consists of a flat array of objects (maps). This means that configuration nodes, for example, may be located anywhere in this array, even *after* the service nodes that utilise these config nodes.\n\nAs there is an implicit dependency between service nodes that use a configuration node or a function node that makes use of a module node, it is import to retrieve and store config nodes first and install module nodes first before spinning up service and function nodes that utilise these nodes.\n\nPhase one is therefore concerned with pre-initialisation steps, a kind of ordering of the flow and ensuring that nodes can be started with all their dependencies already available.\n\n### Description of steps\n\nAs described above, the first action is to extract configuration details from the flow:\n\n- **(1)** call to `store_config_nodes/2` takes the node collection that define a flow selects all config nodes. What is a config node? Node-RED provides no help there and again it is a [look-up table](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl#L355-L360) that provides the answer. A hard-coded look up table is not a long term solution, it's a stop-gap solution.\n\nNode-RED allows node packages to define global objects that can be accessed by service nodes. It provides APIs for doing that. Erlang-Red provides a [config store](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/servers/ered_config_store.erl) service as the centralised global store. At the time of writing, this store is a simple gen_server with a lookup table as state.\n\nStorage of configuration nodes is done before the service nodes are started. Services nodes are started in step **(4)** of phase **two** below. Access to the config store is exampled by the [mqtt node](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_mqtt_in.erl#L239). Each service node is configuted with a global unique ID reference to the config nodes that provides it configuration.\n\n- **(2)** call to `install_module_node_code/2` allows for code inject into Erlang-Red. [Module nodes](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_erlmodule.erl) define modules for use with the event handler and state machine behaviour nodes. **No** checks are done of the correctness nor security of Erlang code injected via the Erlang module node.\n\nAgain modules defined by the module node can be used by other nodes and therefore must be installed before those nodes are started. Security concerns are clear and modules should be *used with caution*.\n\nTo install node code, the `ered_node_erlmodule:install/2` function is called with the node definition containing the Erlang module code. The node definition is the map representation of the original JSON object definition of the node.\n\n- **(3)** call to `extract_supervisors/1` retrieves all the supervisors from the collection of nodes. Supervisor nodes completely manage the lifecycle of the nodes that it supervises. This step *extracts* from the collection of flow nodes, all supervisor nodes and creates two lists of nodes: supervisors and non-supervisors.\n\nIn the case of supervisors of supervisors, both nodes are classified as *supervisors* for the purpose of this splitting of the node definitions. What defines a supervisor? Again this is done using a hard-coded, sub-optimal [lookup table](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_startup.erl#L364-L370).\n\n- **(4)** call to `supervisor_filter_nodes/5` has the responsibility of further splitting the non-supervisor nodes into those that are supervised and those that are not supervised. Supervised nodes are removed from the node list and attached to their supervisor node.\n\nThis step is slightly complicated since to support a supervisor-of-a-supervisor-of-a-supervisor-of... pattern it is necessary that nodes are only attached to their supervisor if these have all their nodes attached. If a supervisors that are being supervised are defined first, then this cannot happen in one iteration through the list of nodes.\n\nThe collection of nodes has no order so this step iterates multiple times through the list of nodes until all nodes (that have a supervisor) have been attached to their supervisor and that supervisor is potentially attached to its supervisor and that supervisor is also attached to its supervisor. It's supervisors all the way up.\n\nIt is not supported that one node has two *direct* supervisors, i.e., the node would belong to two supervisors. It is possible though that a node has two or more heirarchical supervisors.\n\nEach supervisor selects its own list of nodes by defining the `SupervisourModule:extract_nodes/3` function that returns a reduced list of nodes if all nodes that it is supervising were found in that list, else the original list of nodes is returned. The iteration continues with the next supervisor node until all supervisor nodes have been configured.\n\nFor the purposes of this iteration, supervisor nodes are part of the list of all nodes but only once they have obtained all the nodes their are supervising. Supervisors add themselves to the list by including themselves as part of the reduced list of nodes.\n\n- **(5)** call to `create_pids_for_nodes/3` which is passed a single collection of nodes with each node either being a supervisor or a service node or an internal logic node. This is list contains only nodes for which a Erlang process should be started. The create pids for nodes function does not distinguish between nodes, it tells each and every one of them to start an Erlang process for itself.\n\nThe details of which are described by phase two.\n\n## Start up - Phase two\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph LR\nfd298b0409083e41@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" } -- \"call_to\" --> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } == \"Pid\" ==> fd298b0409083e41@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;1#41;** call_to\" --> 020edf6a03f5f1e1@{ shape: \"text\", label: \"node_type_to_module#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;2#41;** call_to\" --> 771995a172e88ca0@{ shape: \"text\", label: \"get_node_name#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;3#41;** call_to\" --> 5c278940932c7d45@{ shape: \"text\", label: \"clear_pg_group#40;GrpName#41;\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;4#41;** call_to\" --> 7c90b2efc29436de@{ shape: \"text\", label: \" Module:start#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;5#41;** call_to\" --> b610359d7e58d2d3@{ shape: \"text\", label: \"gen_server:call#40;Pid, #123;registered, WsName, Pid#125;#41;,\" }\n020edf6a03f5f1e1@{ shape: \"text\", label: \"node_type_to_module#47;2\" } == \"Module\" ==> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n771995a172e88ca0@{ shape: \"text\", label: \"get_node_name#47;2\" } == \"GrpName\" ==> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n7c90b2efc29436de@{ shape: \"text\", label: \" Module:start#47;2\" } == \"Pid\" ==> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n7c90b2efc29436de@{ shape: \"text\", label: \" Module:start#47;2\" } -- \"call_to\" --> 1587728bde29a151@{ shape: \"text\", label: \"spin_up_and_link_node#47;2\" }\nsubgraph \" \"\n7d549ef8f1abdf52\n020edf6a03f5f1e1\n771995a172e88ca0\n5c278940932c7d45\n7c90b2efc29436de\nb610359d7e58d2d3\nend\n```\n*Function calls are ordered and shown in **(1)** numbering. Thick arrows are return values, thin arrows are function calls.*\n\n\nThe `create_pids_for_nodes/3` function is a tail-recursion function that calls `spin_up_node/2` for each node in the list of nodes passed to create pids for nodes function. Diagram 2 visual describes what spin up node function does.\n\n### Steps \n\n- **(1)** call to `node_type_to_module/2` which returns the module corresponding to the node type. As described above, this is a sub-optimal solution of having a hard-coded lookup table in the Erlang code. But for now it works. This function returns is an Erlang `Module` which will be used to start the node process for the node.\n\n- **(2)** call to `get_node_name/2` provides a unique name for this process of the node. Because Erlang-Red can be used by multiple clients, there needs to be a scoping across these clients. Each client can execute each flow with *their* parameters and get *their* results. This requirement implies that there are - in fact - multiple processes for each node.\n\nTo implement this and to avoid flooding the atom registry, I am using a `pg`-based mapping between node and process based on the websocket id of the client. This mapping is respected when nodes send messages to each other. How this works is to define [`pg`](https://www.erlang.org/doc/apps/kernel/pg.html) groups using a specific [naming convention](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_nodes.erl#L106). Each group contains the process id of the current instance of the node for that web-socket, i.e., client.\n\nThis setup has the added bonus that if node processes are restarted by a supervisor node, inter-node communication continues unabated. This is because each time a node wants to send another node a message, it does a lookup in the `pg` table to find the group that contains the process id of the node that should receive the message. Because all nodes have a web-socket client-id, their communication is automagically scoped by the client.\n\nThis could be done just as well by using the `erlang:register` functionality to give processes names. However this would end up polluting the atom namespace and also ensuring the overflowing of that namespace. Erlang has limitations on the number of atoms that may be defined.\n\n- **(3)** call to `clear_pg_group/1` when a new process is started, any existing processes are removed from the group. Normally this group would contain exactly one process and that is [enforced](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_nodes.erl#L111-L121) however adding extra processes to this group to monitor inter-node communication is definitely possible.\n\nMonitoring of message passing between nodes is already possible using the [message tracing](https://github.com/gorenje/erlang-red/commit/512b5e16a7f793fd1ab1974cc90a1e176c992b9b) feature, and in my opinion, is something that is essential to any visual flow based solution. This feature can be activated *without* redeployment of flows. Why is this important? Because the Node-RED way of doing this is by adding a debug node and redeploying the flow to activate the debug node. But that has the downfall of disturbing a running system that might well be fixed by a redeploy - *have you tried turning it on and off again?*.\n\nIt is a bugbear of many Node-RED users and something that I originally fixed in Node-RED using the [introspection](https://flows.nodered.org/node/@gregoriusrippenstein/node-red-contrib-introspection) node package. That can do the same message tracing in Node-RED, i.e., any node can be monitored and no redeployment is necessary. This is a good example of implementation of ideas that can be shared across visual solutions: it does not matter whether Node-RED or Erlang-Red, message tracing is a good idea!\n\n- **(4)** call to `Module:start/2` finally spins up the process for the node. Since all node modules implement the `ered_node` behaviour, the excitiing stuff is actually in the [start function in ered_node](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_node.erl#L56-L60). Also note that the `ered_node` behaviour implements the `gen_server` behaviour that then makes all nodes compatiable with the supervisor behaviour and hence the [supervisor](https://flows.red-erik.org/f/211405fa9e8a6f9b) node.\n\nThe `start/1` function also allows node modules to perform node specific functionality at start up time. However because the process id of the node is not set at that point, most of the initialisation of the node is done in the registered event handler.\n\n- **(5)** call to `gen_server:call(Pid, {registered, WsName, Pid})` on each node process that was created. This call is performed immediately after the start functionality has completed. This call allows the node to register itself - using its own process id - with services that it requires to function correctly. \n\nFinally the process ids are passed up the call chain and the flow has been started. If there are third party services such as MQTT listeners, then messages might be generated straight away. The next section will descibe what happens when a flow is deployed via the flow editor and an initial message is generated via an inject node.\n\n## Flow instantiation and message triggering\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph TB\n9b62183f75d29ea6@{ shape: \"braces\", label: \"Deploy \\n &lt;Flow Editor&gt;\" } -- \"JSON string\" --> 374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" }\n15346d38f116f3ac@{ shape: \"rect\", label: \"Startup \\n &lt;ered_startup.erl&gt;\" } == \"ProcessIDs\" ==> 01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" }\n01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" } == \"&lt;&lt;#123;#34;rev#34;:#34;fed00d06#34;#125;&gt;&gt;\" ==> 374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" }\n01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" } -- \"create_pids_for_nodes#47;2\" --> 15346d38f116f3ac@{ shape: \"rect\", label: \"Startup \\n &lt;ered_startup.erl&gt;\" }\n01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" } -. \"Pid ! #123; stop #125;\" .-> 8e9bfb43fbc19e6c@{ shape: \"rect\", label: \"Node Process\" }\n374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" } -- \"NodeDefinitions - List of Maps \" --> 01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" }\n374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" } == \"&lt;&lt;#123;#34;rev#34;:#34;fed00d06#34;#125;&gt;&gt;\" ==> 9b62183f75d29ea6@{ shape: \"braces\", label: \"Deploy \\n &lt;Flow Editor&gt;\" }\n```\n\nWhat happens when the deploy button is pressed? First the a JSON is created by the flow editor and sent to the server. The server converts the JSON to a list of maps and passes it on to the compute engine that is responsible for managing flow execution.\n\nThe compute engine first retrieves all the relevant `pg` groups that for the flow being deployed. Having a naming convention for these groups, it is a matter of using the web-socket ID to create a prefix for group names. Each member of each of these groups is sent a `stop` message.\n\n\n## Erlang Code\n\n- [ered_startup.erl](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl)\n- [ered_node_erlsupervisor.erl](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_erlsupervisor.erl)\n- [ered_node_erlmodule.erl](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_erlmodule.erl)\n- [ered_compute_engine.erl](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/servers/ered_compute_engine.erl)\n- [ered_node.erl](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_node.erl)\n\n","env":[]},{"id":"e55f8f8977682317","type":"group","z":"2d51a745ca17dc05","name":"ered_startup:create_pids_for_nodes/2","style":{"label":true},"nodes":["cd65242359acde9d","f7b57f5fa2684033","06d71e4d226a0b66","6f2a3728abcf40e8","4b74abd49857f467","993f43fc0fd83c72"],"x":493,"y":377,"w":659,"h":529},{"id":"cb362fe8a180a0e0","type":"group","z":"2d51a745ca17dc05","name":" ","style":{"label":true},"nodes":["7d549ef8f1abdf52","020edf6a03f5f1e1","771995a172e88ca0","5c278940932c7d45","7c90b2efc29436de","b610359d7e58d2d3"],"x":1670.25,"y":384,"w":734.5,"h":484.5},{"id":"cd65242359acde9d","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"ered_startup.erl","shape":"doc","wirecfgs":[{"arrow":"-->","id":"f7b57f5fa2684033","name":"**(1)** call_to"},{"arrow":"-->","id":"993f43fc0fd83c72","name":"**(5)** call_to"},{"arrow":"-->","id":"6f2a3728abcf40e8","name":"**(3)** call_to"},{"arrow":"-->","id":"4b74abd49857f467","name":"**(4)** call_to"},{"arrow":"-->","id":"06d71e4d226a0b66","name":"**(2)** call_to"}],"x":599,"y":418,"wires":[["f7b57f5fa2684033","06d71e4d226a0b66","6f2a3728abcf40e8","4b74abd49857f467","993f43fc0fd83c72"]]},{"id":"f7b57f5fa2684033","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"store_config_nodes/2","shape":"text","wirecfgs":[{"arrow":"-->","id":"deebe7665f77dc9a","name":"store_config_node"}],"x":986,"y":418,"wires":[["deebe7665f77dc9a"]]},{"id":"deebe7665f77dc9a","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"ered_config_store \\n <gen_server>","shape":"lin-cyl","wirecfgs":[],"x":1378,"y":418,"wires":[[]]},{"id":"06d71e4d226a0b66","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"install_module_node_code/2","shape":"text","wirecfgs":[{"arrow":"-->","id":"b8a1bc7329daec62","name":"install/2"}],"x":1006,"y":538,"wires":[["b8a1bc7329daec62"]]},{"id":"647f1caf18f4e461","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Outside World","shape":"braces","wirecfgs":[{"arrow":"-->","id":"cd65242359acde9d","name":"create_pids_for_nodes/2"}],"x":285,"y":418,"wires":[["cd65242359acde9d"]]},{"id":"b8a1bc7329daec62","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"ered_node_erlmodule","shape":"notch-rect","wirecfgs":[],"x":1388,"y":535,"wires":[[]]},{"id":"6f2a3728abcf40e8","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"extract_supervisors/1","shape":"text","wirecfgs":[{"arrow":"==>","id":"cd65242359acde9d","name":"Supervisors"}],"x":986,"y":658,"wires":[["cd65242359acde9d"]]},{"id":"4b74abd49857f467","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"supervisor_filter_nodes/5","shape":"text","wirecfgs":[{"arrow":"-->","id":"94123abe4da26501","name":"extract_nodes/2"}],"x":996,"y":778,"wires":[["94123abe4da26501"]]},{"id":"993f43fc0fd83c72","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"create_pids_for_nodes/3","shape":"text","wirecfgs":[{"arrow":"--","id":"fd298b0409083e41","name":"defintion of"},{"arrow":"==>","id":"647f1caf18f4e461","name":"Pids"}],"x":1000,"y":865,"wires":[["647f1caf18f4e461"]]},{"id":"fd298b0409083e41","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"create_pids_for_nodes/3","shape":"text","wirecfgs":[{"arrow":"-->","id":"7d549ef8f1abdf52","name":"call_to"}],"x":1762.5,"y":247.5,"wires":[["7d549ef8f1abdf52"]]},{"id":"7d549ef8f1abdf52","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"spin_up_node/2","shape":"text","wirecfgs":[{"arrow":"==>","id":"fd298b0409083e41","name":"Pid"},{"arrow":"-->","id":"b610359d7e58d2d3","name":"**(5)** call_to"},{"arrow":"-->","id":"7c90b2efc29436de","name":"**(4)** call_to"},{"arrow":"-->","id":"771995a172e88ca0","name":"**(2)** call_to"},{"arrow":"-->","id":"5c278940932c7d45","name":"**(3)** call_to"},{"arrow":"-->","id":"020edf6a03f5f1e1","name":"**(1)** call_to"}],"x":1776.25,"y":425,"wires":[["fd298b0409083e41","020edf6a03f5f1e1","771995a172e88ca0","5c278940932c7d45","7c90b2efc29436de","b610359d7e58d2d3"]]},{"id":"020edf6a03f5f1e1","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"node_type_to_module/2","shape":"text","wirecfgs":[{"arrow":"==>","id":"7d549ef8f1abdf52","name":"Module"}],"x":2121.25,"y":425,"wires":[["7d549ef8f1abdf52"]]},{"id":"771995a172e88ca0","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"get_node_name/2","shape":"text","wirecfgs":[{"arrow":"==>","id":"7d549ef8f1abdf52","name":"GrpName"}],"x":2107.5,"y":542.5,"wires":[["7d549ef8f1abdf52"]]},{"id":"5c278940932c7d45","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"clear_pg_group(GrpName)","shape":"text","wirecfgs":[],"x":2140,"y":640,"wires":[[]]},{"id":"7c90b2efc29436de","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":" Module:start/2","shape":"text","wirecfgs":[{"name":"Pid","id":"7d549ef8f1abdf52","arrow":"==>"},{"name":"call_to","id":"1587728bde29a151","arrow":"-->"}],"x":2101.25,"y":733.75,"wires":[["7d549ef8f1abdf52","1587728bde29a151"]]},{"id":"b610359d7e58d2d3","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"gen_server:call(Pid, {registered, WsName, Pid}),","shape":"text","wirecfgs":[],"x":2198.75,"y":827.5,"wires":[[]]},{"id":"94123abe4da26501","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Supervisor Module","shape":"notch-rect","wirecfgs":[],"x":1386,"y":777,"wires":[[]]},{"id":"374844f0a340e840","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Deploy Route \\n <ered_http_nodered_flow_deploy_handler>","shape":"rounded","wirecfgs":[{"name":"<<{\"rev\":\"fed00d06\"}>>","id":"9b62183f75d29ea6","arrow":"==>"},{"name":"NodeDefinitions - List of Maps ","id":"01041555183d1b0b","arrow":"-->"}],"x":2962.178680419922,"y":436.9286003112793,"wires":[["01041555183d1b0b","9b62183f75d29ea6"]]},{"id":"9b62183f75d29ea6","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Deploy \\n <Flow Editor>","shape":"braces","wirecfgs":[{"arrow":"-->","id":"374844f0a340e840","name":"JSON string"}],"x":2962.178680419922,"y":266.60716980695724,"wires":[["374844f0a340e840"]]},{"id":"15346d38f116f3ac","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Startup \\n <ered_startup.erl>","shape":"rect","wirecfgs":[{"name":"ProcessIDs","id":"01041555183d1b0b","arrow":"==>"}],"x":2939.3213653564453,"y":772.7143688201904,"wires":[["01041555183d1b0b"]]},{"id":"01041555183d1b0b","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Compute Engine \\n <ered_compute_engine.erl>","shape":"rounded","wirecfgs":[{"name":"Pid ! { stop }","id":"8e9bfb43fbc19e6c","arrow":"-.->"},{"name":"<<{\"rev\":\"fed00d06\"}>>","id":"374844f0a340e840","arrow":"==>"},{"name":"create_pids_for_nodes/2","id":"15346d38f116f3ac","arrow":"-->"}],"x":2962.178680419922,"y":607.2500308156013,"wires":[["374844f0a340e840","15346d38f116f3ac","8e9bfb43fbc19e6c"]]},{"id":"1587728bde29a151","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"spin_up_and_link_node/2","shape":"text","wirecfgs":[],"x":2585.7140731811523,"y":729.2857294082642,"wires":[[]]},{"id":"8e9bfb43fbc19e6c","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Node Process","shape":"rect","wirecfgs":[],"x":3326,"y":685,"wires":[[]]}]