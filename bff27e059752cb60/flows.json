[{"id":"bff27e059752cb60","type":"tab","label":"[tcp] session with state machine","disabled":false,"info":"## Combining connections and state machines\n\nThis example uses a state machine to control the number of connections made to the server.\n\nOne connection is allowed at all times.\n\nThis is enforced by the <a class=\"ahl-node-only\" data-ids=\"6ed338acd5d4f020\">state machine node</a> that maintains connection state.\n\nParallel to that, a second flow provides an interface for the connection to interact with the user.\n\n## How does this work?\n\nAs connections come in, their data flows in two separate flows.\n\nOne flow responds and the other checks the state of the overall system. \n\nOnce the state machine hits its limit, it disconnects any new connections. \n\nIf a response is meant to be sent, its not if the connection has been closed.\n\n","env":[{"name":"ERED_PENDING","value":"true","type":"bool"}]},{"id":"1d162492dd79abb3","type":"group","z":"bff27e059752cb60","name":"enforce a single connection","style":{"label":true},"nodes":["6ed338acd5d4f020","269ef88b6e5dfe87","2fb1c9e4acd00e7c","64614c1426867215","d6116b5c531ce565"],"x":359,"y":86,"w":564,"h":281},{"id":"8ccba23ce4a6d1ec","type":"group","z":"bff27e059752cb60","name":"handle communication with a connection","style":{"label":true},"nodes":["c0d9ca36b10a7a41","c01f45843fbf19e4","4ece615b2733e9e9","5d3db4e403b3db7b","f418dc8563c0be2a","b1b2bb8e2ca4589a"],"x":237,"y":473,"w":815,"h":218.5},{"id":"c0d9ca36b10a7a41","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"set payload to 'prompt> '","rules":[{"t":"set","p":"payload","pt":"msg","to":"prompt> ","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":880,"y":650.5,"wires":[["ce3d569a01e36814"]]},{"id":"ce3d569a01e36814","type":"tcp out","z":"bff27e059752cb60","name":"","host":"","port":"","beserver":"reply","base64":false,"end":false,"tls":"","x":1312,"y":549.5,"wires":[]},{"id":"c01f45843fbf19e4","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"exit","vt":"str"},{"t":"eq","v":"quit","vt":"str"},{"t":"cont","v":"hello","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":4,"x":620,"y":578,"wires":[["4ece615b2733e9e9"],["4ece615b2733e9e9"],["f418dc8563c0be2a"],["c0d9ca36b10a7a41"]]},{"id":"4ece615b2733e9e9","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"set payload & reset connection","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"closed\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":896,"y":551.5,"wires":[["ce3d569a01e36814"]]},{"id":"5d3db4e403b3db7b","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"ignore closed connections","property":"_session.status","propertyType":"msg","rules":[{"t":"neq","v":"closed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":383,"y":514,"wires":[["b1b2bb8e2ca4589a"]]},{"id":"f418dc8563c0be2a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"set payload & reset connection","rules":[{"t":"set","p":"payload","pt":"msg","to":"\"hello, what is your name\" & \"\\n\" & \"enter name> \"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":881,"y":597,"wires":[["ce3d569a01e36814"]]},{"id":"b1b2bb8e2ca4589a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"","rules":[{"t":"set","p":"payload","pt":"msg","to":"$replace($$.payload, \"\\n\",\"\")","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":423,"y":580,"wires":[["c01f45843fbf19e4"]]},{"id":"6ed338acd5d4f020","type":"erlstatemachine","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","module_name":"ensure_single_connection","nodeid":"2fb1c9e4acd00e7c","emit_on_state_change":false,"x":767,"y":183,"wires":[["64614c1426867215"]]},{"id":"b42afac9028901f4","type":"tcp in","z":"bff27e059752cb60","name":"","server":"server","host":"","port":"2424","datamode":"stream","datatype":"utf8","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":132,"y":278,"wires":[["5d3db4e403b3db7b","269ef88b6e5dfe87"]]},{"id":"269ef88b6e5dfe87","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","rules":[{"t":"set","p":"action","pt":"msg","to":"_session.status","tot":"msg"},{"t":"set","p":"payload","pt":"msg","to":"_session.id","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":465,"y":278,"wires":[["6ed338acd5d4f020"]]},{"id":"2fb1c9e4acd00e7c","type":"erlmodule","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","module_name":"ensure_single_connection","code":"-module(ensure_single_connection).\n\n-behaviour(gen_statem).\n\n-export([\n    start/0,\n    init/1,\n    callback_mode/0,\n    handle_event/4,\n    code_change/4,\n    terminate/3,\n    stop/0\n]).\n\ncallback_mode() -> handle_event_function.\n\n-define(KEEP_STATE(ReplyWith),\n    {keep_state, Data, [{reply, From, ReplyWith}]}\n).\n\n%% API.  This example uses a registered name name()\n%% and does not link to the caller.\nstart() ->\n    gen_statem:start({local, ?MODULE}, ?MODULE, [], []).\n\ninit([]) ->\n    State = disconnected,\n    Data = #{sessionid => none },\n    {ok, State, Data}.\n\n%% Mandatory callback functions\nstop() ->\n    gen_statem:stop(?MODULE).\nterminate(_Reason, _State, _Data) ->\n    void.\ncode_change(_Vsn, State, Data, _Extra) ->\n    {ok,State,Data}.\n\n%%\n%% handler function for state transistions\n%%\n\n\n%%\n%% ------------- Initiated actions\n%%\n%% Connection initiated and state is disconnected --> allow connection and\n%% store the SessionId associated with connection and move to state \"connected\".\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  disconnected,\n  #{ sessionid := none }\n) ->\n    {next_state, connected, #{sessionid => SessionId}, [{reply, From, <<\"ok\">>}]};\n\n%% Connection being initiated but state is already connected however SessionIds\n%% match so this is re-initiating the same connection --> ok\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Connection being initiated but state is already connected and SessionIds\n%% do not match --> not allowed. This is a fall through, if SessionIds did match\n%% then rule above would have matched.\nhandle_event({call, From}, {<<\"initiated\">>, _SessionId}, connected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% ------------- Connected actions\n%%\n%% \"Connected\" actions is data being sent to server from client. If the data\n%% is being sent but the sessionid does not match, drop the connection. Else\n%% let the connection be - if we're connected and the session ids match.\n\n%% Data sent and session ids match --> ok\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% State is our current state is connected and data is being sent. The session\n%% IDs don't match --> not allowed\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, _SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%% Data being sent but our current state is disconnected --> not allowed\nhandle_event({call, From}, {<<\"connected\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% -------------- Closed action\n%%\n%% \"Closed\" action are generated when the connection was closed, either by the\n%% server or by the client.\n\n%% Current state is \"connected\" and the action is closed, the SessionIds match\n%% so the state becomese \"disconnected\" and session id is removed.\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId }\n) ->\n    {next_state, disconnected, #{sessionid => none}, [{reply, From, <<\"ok\">>}]};\n\n%% Closed action, current state is \"connected\" and SessionIds do not match\n%% --> nothing to do, keep current state. No need to close a closed connection!\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Current state is \"disconnected\" and a closed action happens --> do nothing.\nhandle_event({call, From}, {<<\"closed\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%%\n%% Fall through.\nhandle_event({call, From} = EventType, Stiff, State, Data) ->\n    io:format(\"TEST (call): ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\nhandle_event(EventType, Stiff, State, Data) ->\n    io:format(\"TEST : ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    {keep_state, Data}.\n","x":757,"y":127,"wires":[]},{"id":"64614c1426867215","type":"switch","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"not_allowed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":734,"y":255,"wires":[["d6116b5c531ce565"]]},{"id":"d6116b5c531ce565","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"too many connections\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":756,"y":326,"wires":[["ce3d569a01e36814"]]}]