[{"id":"bff27e059752cb60","type":"tab","label":"[tcp] single connection using state machines","disabled":false,"info":"## Combining tcp in and state machines\n\nHaving thrown together a set of TCP nodes, I wanted to create a telnet server to demonstrate simple interactions with clients. That sort of happened in the [telnet server flow](https://flows.red-erik.org/f/2a95a7b40a798878).\n\nNext step was to create a session management to give the client the feeling that they were unique. I then realised that multiple concurrent connections could be made using the telnet flow.\n\nBecause I wanted to do this step by step, I decided to create a flow that would ensures that only one client is connected at any one time. That makes thinking about about session per client simpler - I thought. (I mean there are 65536 (or 64535 minues the root-only ports) ports available, one port per client would be 64k concurrent clients - plenty!)\n\nFor the single connection at any one time solution, I wanted to utilise the [statemachine node](https://github.com/gorenje/erlang-red/blob/1a0e15add512d3e2eb892fb70f9d30db30a60be3/src/nodes/ered_node_erlstatemachine.erl).\n\n## How does a state machine work?\n\nErlang has message queues and each message is atomically handled by a process, i.e., there is no concurrent handling of messages by a single process. Regardless of how the message is sent to the process - via cast, call or info.\n\nSince Erlang-Red builds on top of that, it also guarantees that messages are handled in order and atomically by nodes.\n\nThe <a class=\"ahl-node-only\" data-ids=\"6ed338acd5d4f020\">state machine node</a> uses the `gen_statem` behaviour to model a statemachine based on the module defined in the <a class=\"ahl-node-only\" data-ids=\"2fb1c9e4acd00e7c\">ensure_single_connection module node</a>.\n\nThe statemachine has two states: `connected` and `disconnected` and stores the tcp connection session id as single value.\n\n## How does the tcp in node work?\n\n<a class=\"ahl-node-only\" data-ids=\"b42afac9028901f4\">Tcp in node</a> sends out messages per connection per data packet. For string based connections, a message is generated each time the client hits enter. Newline symbol becomes the trigger.\n\nEach client, i.e., connection to the tcp server, is assigned a unique **session id** that is attached to each message generated by that connection.\n\nFinally each message generated by the tcp in node also has a **status** value to indicate whether a connection is new, is sending data or has been closed. Possible [values](https://github.com/gorenje/erlang-red/blob/1a0e15add512d3e2eb892fb70f9d30db30a60be3/src/nodes/ered_node_tcp_in.erl#L106-L114) for the status are `initiated`, `connected` and `closed`.\n\nA typical message from a tcp in node has the format:\n\n```erlang\n<<\"_session\">> => #{\n    <<\"type\">>   => <<\"tcp\">>,\n    <<\"id\">>     => SessionId,\n    <<\"status\">> => Status\n},\n<<\"ip\">>      => InterfaceIp,\n<<\"topic\">>   => maps:get(<<\"topic\">>, NodeDef),\n<<\"payload\">> => Payload\n```\n\nThe topic value is assigned to the tcp in node so tht all messages, for all clients, have the same topic value but that does not interest us here.\n\n(BTW this message format is conform to Node-REDs tcp in node except for the `_session.status` value, that Node-RED does not have.)\n\n## State machine and tcp in messages\n\nEach state machine node expects an `action` value and optionally a `payload` value set on the messages it receives. \n\nWhat the <a class=\"ahl-node-only\" data-ids=\"269ef88b6e5dfe87\">change node</a> does is set the `payload` to the session id, i.e. `msg.payload = msg._session.id` and the action to the status, i.e., `msg.action = msg._session.status`.\n\nFor each message the sate machine recieves, it then computes a response of either `ok` or `not_allowed`. Not allowed connections are disconnect by setting <a class=\"ahl-node-only\" data-ids=\"d6116b5c531ce565\">`msg.reset = true`</a> and sending the message to the <a class=\"ahl-node-only\" data-ids=\"ce3d569a01e36814\">tcp out</a> node. \n\n## What happens when tcp out closes a connection?\n\nThe <a class=\"ahl-node-only\" data-ids=\"b42afac9028901f4\">tcp in</a> node generates the `closed` status message for the connection and the state machine can reset its state - if its the connection its maintaining - to `disconnected`.\n\nThe state machine has two states and a session id, the states indicate what the session id is doing - i.e., connected. Once the state machine is disconnected, the session id is set to `none`. The next connection will then be set as the connections stored by the state machine. To put that visually:\n\n| state | message status | session ids | new state | outcome |\n| ----- | -------------- | ---------- | --------- | ------- |\n| disconnected | closed | match | disconnected | ok |\n| disconnected | closed | dont match | disconnected | ok |\n\n#programmingBreadboard","env":[{"name":"ERED_PENDING","value":"true","type":"bool"}]},{"id":"1d162492dd79abb3","type":"group","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"enforce a single connection","style":{"label":true},"nodes":["6ed338acd5d4f020","269ef88b6e5dfe87","64614c1426867215","d6116b5c531ce565"],"x":312.28563690185547,"y":275.00004959106445,"w":953.9999618530273,"h":188.28569793701172},{"id":"8ccba23ce4a6d1ec","type":"group","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"handle communication with a connection","style":{"label":true},"nodes":["c0d9ca36b10a7a41","c01f45843fbf19e4","4ece615b2733e9e9","5d3db4e403b3db7b","f418dc8563c0be2a","b1b2bb8e2ca4589a"],"x":272.71414947509766,"y":487.2856607437134,"w":834.9999694824219,"h":209.35718822479248},{"id":"e5c9a8daced2036d","type":"group","z":"bff27e059752cb60","name":"state machine modules","style":{"label":true},"nodes":["2fb1c9e4acd00e7c"],"x":51,"y":30,"w":272,"h":82},{"id":"54e4c3fae17a3580","type":"group","z":"bff27e059752cb60","name":"disconnect connections in parallel","style":{"label":true},"nodes":["ce3d569a01e36814","b42afac9028901f4","1d162492dd79abb3","8ccba23ce4a6d1ec"],"x":63.14272689819336,"y":249.00004959106445,"w":1367.7142143249512,"h":473.6427993774414},{"id":"c0d9ca36b10a7a41","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"send prompt>","rules":[{"t":"set","p":"payload","pt":"msg","to":"prompt> ","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":941.7141189575195,"y":655.6428489685059,"wires":[["ce3d569a01e36814"]]},{"id":"ce3d569a01e36814","type":"tcp out","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"","host":"","port":"","beserver":"reply","base64":false,"end":false,"tls":"","x":1354.8569412231445,"y":655.6428489685059,"wires":[]},{"id":"c01f45843fbf19e4","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"what payload?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"exit","vt":"str"},{"t":"eq","v":"quit","vt":"str"},{"t":"cont","v":"hello","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":4,"x":717.1426849365234,"y":586.5713996887207,"wires":[["4ece615b2733e9e9"],["4ece615b2733e9e9"],["f418dc8563c0be2a"],["c0d9ca36b10a7a41"]]},{"id":"4ece615b2733e9e9","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"quit and close connection","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"closed\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":971.7141189575195,"y":529.4999713897705,"wires":[["ce3d569a01e36814"]]},{"id":"5d3db4e403b3db7b","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"ignore closed connections","property":"_session.status","propertyType":"msg","rules":[{"t":"neq","v":"closed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":418.71414947509766,"y":528.2856607437134,"wires":[["b1b2bb8e2ca4589a"]]},{"id":"f418dc8563c0be2a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"obtain name of user","rules":[{"t":"set","p":"payload","pt":"msg","to":"\"hello, what is your name?\" & \"\\n\" & \"enter name> \"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":961.7141189575195,"y":592.5714101791382,"wires":[["ce3d569a01e36814"]]},{"id":"b1b2bb8e2ca4589a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"remove newlines from payload","rules":[{"t":"set","p":"payload","pt":"msg","to":"$replace($$.payload, \"\\n\",\"\")","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":470.14270782470703,"y":586.5713996887207,"wires":[["c01f45843fbf19e4"]]},{"id":"6ed338acd5d4f020","type":"erlstatemachine","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","module_name":"ensure_single_connection","nodeid":"2fb1c9e4acd00e7c","emit_on_state_change":false,"x":714.1427536010742,"y":328.00004959106445,"wires":[["64614c1426867215"]]},{"id":"b42afac9028901f4","type":"tcp in","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"","server":"server","host":"","port":"2424","datamode":"stream","datatype":"utf8","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":149.14272689819336,"y":328.00004959106445,"wires":[["5d3db4e403b3db7b","269ef88b6e5dfe87"]]},{"id":"269ef88b6e5dfe87","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"set action and payload \\n for the state machine","rules":[{"t":"set","p":"action","pt":"msg","to":"_session.status","tot":"msg"},{"t":"set","p":"payload","pt":"msg","to":"_session.id","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":438.28563690185547,"y":328.00004959106445,"wires":[["6ed338acd5d4f020"]]},{"id":"2fb1c9e4acd00e7c","type":"erlmodule","z":"bff27e059752cb60","g":"e5c9a8daced2036d","name":"","module_name":"ensure_single_connection","code":"-module(ensure_single_connection).\n\n-behaviour(gen_statem).\n\n-export([\n    start/0,\n    init/1,\n    callback_mode/0,\n    handle_event/4,\n    code_change/4,\n    terminate/3,\n    stop/0\n]).\n\ncallback_mode() -> handle_event_function.\n\n-define(KEEP_STATE(ReplyWith),\n    {keep_state, Data, [{reply, From, ReplyWith}]}\n).\n\n%% API.  This example uses a registered name name()\n%% and does not link to the caller.\nstart() ->\n    gen_statem:start({local, ?MODULE}, ?MODULE, [], []).\n\ninit([]) ->\n    State = disconnected,\n    Data = #{sessionid => none},\n    {ok, State, Data}.\n\n%% Mandatory callback functions\nstop() ->\n    gen_statem:stop(?MODULE).\nterminate(_Reason, _State, _Data) ->\n    void.\ncode_change(_Vsn, State, Data, _Extra) ->\n    {ok,State,Data}.\n\n%%\n%% handler function for state transistions\n%%\n\n\n%%\n%% ------------- Initiated actions\n%%\n%% Connection initiated and state is disconnected --> allow connection and\n%% store the SessionId associated with connection and move to state \"connected\".\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  disconnected,\n  #{ sessionid := none }\n) ->\n    {next_state, connected, #{sessionid => SessionId}, [{reply, From, <<\"ok\">>}]};\n\n%% Connection being initiated but state is already connected however SessionIds\n%% match so this is re-initiating the same connection --> ok\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Connection being initiated but state is already connected and SessionIds\n%% do not match --> not allowed. This is a fall through, if SessionIds did match\n%% then rule above would have matched.\nhandle_event({call, From}, {<<\"initiated\">>, _SessionId}, connected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% ------------- Connected actions\n%%\n%% \"Connected\" actions is data being sent to server from client. If the data\n%% is being sent but the sessionid does not match, drop the connection. Else\n%% let the connection be - if we're connected and the session ids match.\n\n%% Data sent and session ids match --> ok\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% State is our current state is connected and data is being sent. The session\n%% IDs don't match --> not allowed\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, _SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%% Data being sent but our current state is disconnected --> not allowed\nhandle_event({call, From}, {<<\"connected\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% -------------- Closed action\n%%\n%% \"Closed\" action are generated when the connection was closed, either by the\n%% server or by the client.\n\n%% Current state is \"connected\" and the action is closed, the SessionIds match\n%% so the state becomese \"disconnected\" and session id is removed.\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId }\n) ->\n    {next_state, disconnected, #{sessionid => none}, [{reply, From, <<\"ok\">>}]};\n\n%% Closed action, current state is \"connected\" and SessionIds do not match\n%% --> nothing to do, keep current state. No need to close a closed connection!\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Current state is \"disconnected\" and a closed action happens --> do nothing.\nhandle_event({call, From}, {<<\"closed\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%%\n%% Fall through.\nhandle_event({call, From} = EventType, Stiff, State, Data) ->\n    io:format(\"TEST (call): ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\nhandle_event(EventType, Stiff, State, Data) ->\n    io:format(\"TEST : ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    {keep_state, Data}.\n","x":187,"y":71,"wires":[]},{"id":"64614c1426867215","type":"switch","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"close connection?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"not_allowed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":1009.713996887207,"y":328.00004959106445,"wires":[["d6116b5c531ce565"]]},{"id":"d6116b5c531ce565","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"close connection with \"too many \\n connections\" message","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"too many connections\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1100.2855987548828,"y":410.2857475280762,"wires":[["ce3d569a01e36814"]]}]