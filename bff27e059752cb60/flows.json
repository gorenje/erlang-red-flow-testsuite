[{"id":"bff27e059752cb60","type":"tab","label":"[tcp] single connection using state machines","disabled":false,"info":"## Combining tcp in and state machines\n\nHaving thrown together a set of TCP nodes, I wanted to create a telnet server to demonstrate simple interactions with clients. That sort of happened in the [telnet server flow](https://flows.red-erik.org/f/2a95a7b40a798878).\n\nNext step was to create a session management to give the client the feeling that they were unique. I then realised that multiple concurrent connections could be made using the telnet flow.\n\nBecause I wanted to do this step by step, I decided to create a flow that would ensure that only one client is connected at any one time. That makes creating a unique interaction per client simpler - I thought. For the single connection at any one time solution, I wanted to utilise the [statemachine node](https://github.com/gorenje/erlang-red/blob/1a0e15add512d3e2eb892fb70f9d30db30a60be3/src/nodes/ered_node_erlstatemachine.erl).\n\n## How does a state machine work?\n\nErlang has message queues and each message is atomically handled by a process, i.e., there is no concurrent handling of messages by a single process. Regardless of how the message is sent to the process - via cast, call or info. Since Erlang-Red builds on top of that, it also guarantees that messages are handled in order and atomically by *nodes*.\n\nThe <a class=\"ahl-node-only\" data-ids=\"6ed338acd5d4f020\">state machine node</a> uses the `gen_statem` behaviour to model a statemachine based on the module defined in the <a class=\"ahl-node-only\" data-ids=\"2fb1c9e4acd00e7c\">ensure_single_connection module node</a>. The module defines two states: `connected` and `disconnected` and stores the tcp connection session id as single value.\n\n## How does the tcp in node work?\n\n<a class=\"ahl-node-only\" data-ids=\"b42afac9028901f4\">Tcp in node</a> sends out messages per connection per data packet. For string based connections, a message is generated each time the client hits enter. Newline symbol becomes the trigger.\n\nEach client, i.e., connection to the tcp server, is assigned a unique **session id** that is attached to each message generated by that client, i.e., connection.\n\nFinally each message generated by the tcp in node also has a **status** value to indicate whether a connection is new, is sending data or has been closed. Possible [values](https://github.com/gorenje/erlang-red/blob/1a0e15add512d3e2eb892fb70f9d30db30a60be3/src/nodes/ered_node_tcp_in.erl#L106-L114) for the status are `initiated`, `connected` and `closed`.\n\nA typical message from a tcp in node has the format (in Erlang code representing a key-value store):\n\n```erlang\n<<\"_session\">> => #{\n    <<\"type\">>   => <<\"tcp\">>,\n    <<\"id\">>     => SessionId,\n    <<\"status\">> => Status\n},\n<<\"ip\">>      => InterfaceIp,\n<<\"topic\">>   => maps:get(<<\"topic\">>, NodeDef),\n<<\"payload\">> => Payload\n```\n\nThe topic value is assigned to the tcp in node so that all messages, for all clients, have the same topic value but that does not interest us here.\n\n(BTW this message format is conform to Node-REDs tcp in node except for the `_session.status` value, Node-RED does not define a status.)\n\n## State machine and tcp in messages\n\nEach state machine node expects an `action` value and optionally a `payload` value set on the messages it receives. \n\nWhat the <a class=\"ahl-node-only\" data-ids=\"269ef88b6e5dfe87\">change node</a> does is set the `payload` to the session id, i.e. `msg.payload = msg._session.id` and the action to the status, i.e., `msg.action = msg._session.status`.\n\nFor each message the sate machine recieves, it then computes a response of either `ok` or `not_allowed`. Not allowed connections are disconnect by <a class=\"ahl-node-only\" data-ids=\"d6116b5c531ce565\">setting</a> `msg.reset = true` and sending the message to the <a class=\"ahl-node-only\" data-ids=\"ce3d569a01e36814\">tcp out</a> node. \n\n## What happens when tcp out closes a connection?\n\nThe <a class=\"ahl-node-only\" data-ids=\"b42afac9028901f4\">tcp in</a> node generates the `closed` status message for the connection and the state machine can reset its state to `disconnected` - if its the connection being maintained.\n\nThe state machine has two states and a session id. The session id is the identifier for the single connection that is allowed. Once the state machine is disconnected, the session id is set to `none` but only if the corresponding connection for the session id is closed. \n\nThe next connection will then be set as the new single connection stored by the state machine. To put that visually:\n\n| state | message status | session ids | new state | outcome |\n| ----- | -------------- | ---------- | --------- | ------- |\n| disconnected | closed | - | disconnected | ok |\n| disconnected | initiated | - | connected | ok |\n| disconnected | connected | - | disconnected | not_allowd|\n| connected | initiated | dont match | connected | not_allowed |\n| connected | initiated | match | connected | ok |\n| connected | connected | match | connected | ok |\n| connected | connected | dont match | connected | not_allowed |\n| connected | closed | match | disconnected | ok |\n| connected | closed | dont match | connected | ok |\n| \\<state> | * | * | \\<state> | not_allowed |\n\n**NOTE**: \n\n- When moving from state `disconnected` to `connected`, the session id of the connection is stored. \n- Also when moving from state `connected` to `disconnected`, the session id is set to `none`. \n- Any unforeseen combinations are `not_allowed` and leads to the connection being closed. \n- All outcomes to closed connections is ok since there is no need to close them again! \n- The outcome `not_allowed` implicitly closes the connection but that may not be the case, the `not_allowed` outcome is an indication of the state machine: *this transition is not allowed*, what the flow does is not for the state machine to decide.\n\n## Why does this work?\n\nThis works because the tcp out node and the tcp in node have a common pool of connections they are adminstrating. When the tcp out node is sent a reset request, it uses the session id to retrieve the correct connection. It closes that connection which then triggers a closed message being generated by the tcp in node. The tcp in and tcp out nodes do not communicate directly.\n\nThe statemachine works since it receives one message at a time. And this can cause issues in the <a class=\"ahl-group-only\" data-ids=\"54e4c3fae17a3580\">disconnect connections in parallel</a> flow. What is happening is that a data packet passed out by the tcp in node is cloned and passed to the statemachine and the <a class=\"ahl-group-only\" data-ids=\"8ccba23ce4a6d1ec\">handle communication with a connection</a> flow. This means that *every connection* is sent to the communication flow and can actually communicate with the server.\n\nBut because the <a class=\"ahl-group-only\" data-ids=\"1d162492dd79abb3\">enforce a single connection</a> flow is so \"reliable\" and \"fast\", a connection is closed *before* the user/client can type anything. **BUT** if the state machine fails, then *all* connections are handled by the server. On the other hand, the state machine process runs concurrently to the communciation flow, that makes it faster for the client to interact with the server - not having to interact with the state machine for each data packet sent.\n\nHere we have a classic trade off between security and performance. I am literally not expecting so much traffic that the statemachine process would slow down or fail, so for my use case this first attempt is fine. \n\nHowever this might not be case once spammers, crackers, blackhats and other nefarious computer users discover my open port and suddenly everything goes west.\n\n## Serialisation to the rescue\n\nTo fix this, I create the second flow that ensures that *every* data packet goes through the statemachine, no questions asked, no quarter given.\n\n\n\n\n\n#programmingBreadboard","env":[{"name":"ERED_PENDING","value":"true","type":"bool"}]},{"id":"1d162492dd79abb3","type":"group","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"enforce a single connection","style":{"label":true},"nodes":["6ed338acd5d4f020","269ef88b6e5dfe87","64614c1426867215","d6116b5c531ce565"],"x":312.28563690185547,"y":275.00004959106445,"w":953.9999618530273,"h":188.28569793701172},{"id":"8ccba23ce4a6d1ec","type":"group","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"handle communication with a connection","style":{"label":true},"nodes":["c0d9ca36b10a7a41","c01f45843fbf19e4","4ece615b2733e9e9","5d3db4e403b3db7b","f418dc8563c0be2a","b1b2bb8e2ca4589a"],"x":272.71414947509766,"y":487.2856607437134,"w":834.9999694824219,"h":209.35718822479248},{"id":"e5c9a8daced2036d","type":"group","z":"bff27e059752cb60","name":"state machine modules","style":{"label":true},"nodes":["2fb1c9e4acd00e7c"],"x":51,"y":30,"w":272,"h":82},{"id":"54e4c3fae17a3580","type":"group","z":"bff27e059752cb60","name":"disconnect connections in parallel","style":{"label":true},"nodes":["ce3d569a01e36814","b42afac9028901f4","1d162492dd79abb3","8ccba23ce4a6d1ec"],"x":63.14272689819336,"y":249.00004959106445,"w":1367.7142143249512,"h":473.6427993774414},{"id":"c0d9ca36b10a7a41","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"send prompt>","rules":[{"t":"set","p":"payload","pt":"msg","to":"prompt> ","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":941.7141189575195,"y":655.6428489685059,"wires":[["ce3d569a01e36814"]]},{"id":"ce3d569a01e36814","type":"tcp out","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"","host":"","port":"","beserver":"reply","base64":false,"end":false,"tls":"","x":1354.8569412231445,"y":655.6428489685059,"wires":[]},{"id":"c01f45843fbf19e4","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"what payload?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"exit","vt":"str"},{"t":"eq","v":"quit","vt":"str"},{"t":"cont","v":"hello","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":4,"x":717.1426849365234,"y":586.5713996887207,"wires":[["4ece615b2733e9e9"],["4ece615b2733e9e9"],["f418dc8563c0be2a"],["c0d9ca36b10a7a41"]]},{"id":"4ece615b2733e9e9","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"quit and close connection","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"closed\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":971.7141189575195,"y":529.4999713897705,"wires":[["ce3d569a01e36814"]]},{"id":"5d3db4e403b3db7b","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"ignore closed connections","property":"_session.status","propertyType":"msg","rules":[{"t":"neq","v":"closed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":418.71414947509766,"y":528.2856607437134,"wires":[["b1b2bb8e2ca4589a"]]},{"id":"f418dc8563c0be2a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"obtain name of user","rules":[{"t":"set","p":"payload","pt":"msg","to":"\"hello, what is your name?\" & \"\\n\" & \"enter name> \"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":961.7141189575195,"y":592.5714101791382,"wires":[["ce3d569a01e36814"]]},{"id":"b1b2bb8e2ca4589a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"remove newlines from payload","rules":[{"t":"set","p":"payload","pt":"msg","to":"$replace($$.payload, \"\\n\",\"\")","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":470.14270782470703,"y":586.5713996887207,"wires":[["c01f45843fbf19e4"]]},{"id":"6ed338acd5d4f020","type":"erlstatemachine","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","module_name":"ensure_single_connection","nodeid":"2fb1c9e4acd00e7c","emit_on_state_change":false,"x":714.1427536010742,"y":328.00004959106445,"wires":[["64614c1426867215"]]},{"id":"b42afac9028901f4","type":"tcp in","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"","server":"server","host":"","port":"2424","datamode":"stream","datatype":"utf8","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":149.14272689819336,"y":328.00004959106445,"wires":[["5d3db4e403b3db7b","269ef88b6e5dfe87"]]},{"id":"269ef88b6e5dfe87","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"set action and payload \\n for the state machine","rules":[{"t":"set","p":"action","pt":"msg","to":"_session.status","tot":"msg"},{"t":"set","p":"payload","pt":"msg","to":"_session.id","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":438.28563690185547,"y":328.00004959106445,"wires":[["6ed338acd5d4f020"]]},{"id":"2fb1c9e4acd00e7c","type":"erlmodule","z":"bff27e059752cb60","g":"e5c9a8daced2036d","name":"","module_name":"ensure_single_connection","code":"-module(ensure_single_connection).\n\n-behaviour(gen_statem).\n\n-export([\n    start/0,\n    init/1,\n    callback_mode/0,\n    handle_event/4,\n    code_change/4,\n    terminate/3,\n    stop/0\n]).\n\ncallback_mode() -> handle_event_function.\n\n-define(KEEP_STATE(ReplyWith),\n    {keep_state, Data, [{reply, From, ReplyWith}]}\n).\n\n%% API.  This example uses a registered name name()\n%% and does not link to the caller.\nstart() ->\n    gen_statem:start({local, ?MODULE}, ?MODULE, [], []).\n\ninit([]) ->\n    State = disconnected,\n    Data = #{sessionid => none},\n    {ok, State, Data}.\n\n%% Mandatory callback functions\nstop() ->\n    gen_statem:stop(?MODULE).\nterminate(_Reason, _State, _Data) ->\n    void.\ncode_change(_Vsn, State, Data, _Extra) ->\n    {ok,State,Data}.\n\n%%\n%% handler function for state transistions\n%%\n\n\n%%\n%% ------------- Initiated actions\n%%\n%% Connection initiated and state is disconnected --> allow connection and\n%% store the SessionId associated with connection and move to state \"connected\".\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  disconnected,\n  #{ sessionid := none }\n) ->\n    {next_state, connected, #{sessionid => SessionId}, [{reply, From, <<\"ok\">>}]};\n\n%% Connection being initiated but state is already connected however SessionIds\n%% match so this is re-initiating the same connection --> ok\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Connection being initiated but state is already connected and SessionIds\n%% do not match --> not allowed. This is a fall through, if SessionIds did match\n%% then rule above would have matched.\nhandle_event({call, From}, {<<\"initiated\">>, _SessionId}, connected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% ------------- Connected actions\n%%\n%% \"Connected\" actions is data being sent to server from client. If the data\n%% is being sent but the sessionid does not match, drop the connection. Else\n%% let the connection be - if we're connected and the session ids match.\n\n%% Data sent and session ids match --> ok\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% State is our current state is connected and data is being sent. The session\n%% IDs don't match --> not allowed\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, _SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%% Data being sent but our current state is disconnected --> not allowed\nhandle_event({call, From}, {<<\"connected\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% -------------- Closed action\n%%\n%% \"Closed\" action are generated when the connection was closed, either by the\n%% server or by the client.\n\n%% Current state is \"connected\" and the action is closed, the SessionIds match\n%% so the state becomese \"disconnected\" and session id is removed.\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId }\n) ->\n    {next_state, disconnected, #{sessionid => none}, [{reply, From, <<\"ok\">>}]};\n\n%% Closed action, current state is \"connected\" and SessionIds do not match\n%% --> nothing to do, keep current state. No need to close a closed connection!\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Current state is \"disconnected\" and a closed action happens --> do nothing.\nhandle_event({call, From}, {<<\"closed\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%%\n%% Fall through.\nhandle_event({call, From} = EventType, Stiff, State, Data) ->\n    io:format(\"TEST (call): ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\nhandle_event(EventType, Stiff, State, Data) ->\n    io:format(\"TEST : ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    {keep_state, Data}.\n","x":187,"y":71,"wires":[]},{"id":"64614c1426867215","type":"switch","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"close connection?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"not_allowed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":1009.713996887207,"y":328.00004959106445,"wires":[["d6116b5c531ce565"]]},{"id":"d6116b5c531ce565","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"close connection with \"too many \\n connections\" message","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"too many connections\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1100.2855987548828,"y":410.2857475280762,"wires":[["ce3d569a01e36814"]]}]