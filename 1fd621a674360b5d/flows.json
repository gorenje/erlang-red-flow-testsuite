[{"id":"1fd621a674360b5d","type":"tab","label":"[.docu] junction node architecture","disabled":false,"info":"## Function node Erlang architecture\n\nThe function node is used to execute Erlang code in the context of a message object received by the function node. In combination with the [module](https://flows.red-erik.org/f/442b3bf0d630e21d) node, it can be used to create a complete Erlang application inside of Erlang-Red.\n\nWhen the <a class=\"ahl-node-only\" data-ids=\"7e03f030e5f5a4e7\">inject button</a> is triggered by receiving a [`gen_server:cast(create_outgoing_msg)`](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/routes/ered_http_nodered_inject_node_button_handler.erl#L39-L53) message, the following flowchart of processes is created.\n\n## Flowchart \n\n```mermaid\nflowchart TB\n    3272430156b615cf[\"`ered_node_inject \n      &lt;ered_node&gt;`\"] -- handle_msg/2(outgoing) --> 3142b9a8e864d04f([\"#{Msg}\"])\n    3142b9a8e864d04f -- handle_msg/2(incoming) --> c333a1b8d6ccd24f[\"`ered_node_function \n    &lt;ered_node&gt;`\"]\n    c333a1b8d6ccd24f -- ered_function_code_manager:start/2 --> e9077d2769ed1a86\n    c333a1b8d6ccd24f -. ! perform_func_code .-> e9077d2769ed1a86\n    c333a1b8d6ccd24f -. handle_info/2('DOWN') .-> e9077d2769ed1a86\n    e9077d2769ed1a86 -. handle_event/2('DOWN') .-> c333a1b8d6ccd24f\n    e9077d2769ed1a86 -- elrang:spawn_link/3 --> 3623c7b9447ee093\n    e9077d2769ed1a86 -- erlang:start_timer/3 --> 36fb909a0736d92e\n    3623c7b9447ee093 -. handle_info/2('EXIT') .-> e9077d2769ed1a86 \n    3623c7b9447ee093 -- execute_sync/3 --> cfd2d25f8d7027c4\n    3623c7b9447ee093 -. ! func_completed_with .-> c333a1b8d6ccd24f\n    36fb909a0736d92e -. handle_info/2(timeout) .-> e9077d2769ed1a86\n    cfd2d25f8d7027c4 -- send_message_on_ports/2 --> 1d84888539409a24\n subgraph subGraph0[\"-- for each message --\"]\n        e9077d2769ed1a86[\"`ered_function_code_manager \n        &lt;gen_server&gt;`\"]\n        3623c7b9447ee093[\"`exec func process \n        <erlang process>`\"]\n        cfd2d25f8d7027c4([\"#{Msg2}\"])\n        36fb909a0736d92e[\"`timeout process \n        <erlang process>`\"]\n        1d84888539409a24[\"`ered_node_debug \n        &lt;ered_node&gt;`\"]\n  end\n```\n\nShown are all the communication channels between the moving parts needed to execute the above flow. Not shown is the interaction with a  [supervisor node](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_erlsupervisor.erl).\n\n## Terminology\n\nIn the flowchart:\n\n- dotted lines are Erlang messages between processes\n- rectangles are processes\n- solid line arrows are function calls\n- the oval `#{Msg}` is just a map containing the Erlang-Red message data\n- the yellow sub-graph is spun-up once per Erlang-Red message\n\nThe <a class=\"ahl-node-only\" data-ids=\"2f618851ebb2f1d9\">function node</a> upon receiving a message spins up the `ered_function_code_manager` to handle the code execution of its function within the context of the Erlang-Red message received.\n\nErlang Messages are not to be confused with Erlang-Red messages. Erlang-Red messages are maps that are passed between nodes, Erlang messages are (mostly) tuples passed between Erlang processes.\n\n## Functionality\n\nNot all processes are started all the time. If the function node as no timeout value, as is the case for this flow, then the `timeout process` is not started.\n\nAll messages sent from sub-processes to the `ered_function_code_manager` are propagated up to the (parent) node process. Regardless what type of message the manager receives, it sends a `'DOWN'` message to the node process because the manager, having sent the message, will shutdown. The node process then decides what to do with failures in execution or timeouts or successful execution.\n\nEven though node processes don't and shouldn't die, they do. If the node process does die, then the manager is responsible for cleaning up its processes and also shutting down. When the manager receives a `'DOWN'` message from the node process, then it will shutdown, killing the `exec func process` with it.\n\nThe result of a successful function execution is a new `Msg` object/map which should be passed to the <a class=\"ahl-node-only\" data-ids=\"c964d93feccb251b\">debug node</a>. The debug node is represented by a Erlang process that receives an `handle_event({incoming, Msg})` Erlang message.\n\nOne thing to note is that the `exec func process` actually sends out the new Erlang-Red message to the nodes connected to the function node. It can do that since `wires` that define those connections have been passed to the exec process from the function node process. This has two benefits: better concurrency and less centralisation of Erlang messages in the function node message queue.\n\nFinally the `exec func process` sends a `gen_server:cast(From, {func_completed_with, Msg})` message to the node function process to inform it that the original `#{Msg}` has been handled successfully. This allows the node function to trigger any [completed nodes](https://flows.red-erik.org/f/0c35d269ca7178c6) listening for completion.\n\n## Node processes do not die\n\nThe reason for this architecture is that node processes (i.e. those Erlang processes that represent Erlang-Red nodes) should not die if sub-processes that they start happen to exit abnormally.\n\nA node process is responsible for handling incoming messages and updating the flow editor with the nodes status. \n\n## Code\n\nErlang Code: \n\n- [ered_node_function.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_function.erl), \n- [ered_function_code_manager.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/managers/ered_function_code_manager.erl), \n- [ered_node_inject.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_inject.erl), \n- [ered_node_debug.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_debug.erl)\n\n","env":[{"name":"ERED_TIMEOUT","value":"1","type":"num"}]},{"id":"7e03f030e5f5a4e7","type":"inject","z":"1fd621a674360b5d","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":513.4285278320312,"y":283.9285583496094,"wires":[["2f618851ebb2f1d9"]]},{"id":"2f618851ebb2f1d9","type":"function","z":"1fd621a674360b5d","name":"function 1","func":"%% Code here is wrapped in a fun (Msg) call\n%% fun (Msg) ->\n    Msg\n%% end.\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":737.4285278320312,"y":283.9285583496094,"wires":[["c964d93feccb251b"]]},{"id":"c964d93feccb251b","type":"debug","z":"1fd621a674360b5d","name":"debug 1","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":954.4285278320312,"y":283.9285583496094,"wires":[]}]